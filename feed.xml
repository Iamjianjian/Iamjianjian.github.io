<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>I am JianJian</title>
    <description>Nothing # this means to ignore newlines until &quot;baseurl:&quot;
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 05 Jan 2019 09:06:00 +0800</pubDate>
    <lastBuildDate>Sat, 05 Jan 2019 09:06:00 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>惨痛的系统史</title>
        <description>&lt;h2 id=&quot;第一次伟大的尝试被acer坑惨了&quot;&gt;第一次伟大的尝试被acer坑惨了&lt;/h2&gt;
&lt;p&gt;记得那是学校运动会，身为运动健将的我蹲在宿舍打算为自己的win8找个伴装上一个高比格的centos。直到晚上我才从一堆英文文档中找到答案装上了双系统，两边各开一次确定它们不打架之后安心地睡去了。
然鹅，第二天我的win8只闻其声却一脸黑屏。解决无果只好敲开了曹哥宿舍的门。“啪！”的一下跪下来，曹哥救救我，我电脑爆炸了。然后曹哥果然不负我所托成功装上双系统，……之后win7又黑屏了(看吧，不是我菜,是我们都很菜！我竟然有点小开心)。具体原因至今未知。网上有的说是acer这个系列电脑都有这个问题。反正双系统没有装上，还掉级到了win7（虽然我觉得win7好像比win8好用的样子）。&lt;/p&gt;

&lt;h2 id=&quot;有钱才是爷&quot;&gt;有钱才是爷&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/img/expressions/meiqian.jpg&quot; alt=&quot;meiqian&quot; /&gt;
直到去年春节之前我都是用的虚拟机。然后买了自己第一个固态，拆了光驱托子，装了双硬盘。原来的机械硬盘装光驱位，固态装原来的硬盘位可以用sata3的接口，在固态上面装了fedora。
然鹅问题又来了，装了fedora之后win7鼠标竟然动不了了。一开始以为是驱动问题，键盘操作下了驱动安装重启发现还真的好了。然鹅问题没有那么简单。每次我切换系统，就是如果我一直不开fedora，win7是没有问题的，只要我开了fedora，再开win7都要重启一次win7鼠标才能动。至于为什么，又多了一个历史未解之谜。em…先凑合吧&lt;/p&gt;
&lt;h2 id=&quot;尴尬的4个分区&quot;&gt;尴尬的4个分区&lt;/h2&gt;
&lt;p&gt;关于mbr，如下图只有4个分区
&lt;br /&gt;
&lt;img src=&quot;/img/mbr/partition.gif&quot; alt=&quot;mbr&quot; /&gt;
而我的机械硬盘windows备份用了一个分区，c盘一个，d一个，还有其他的占了用扩展分区占了一个。4个完完整整。还想装系统，是想多了。无论怎么样mbr的4个都很符合我的穷比风格。&lt;/p&gt;
&lt;h2 id=&quot;拥抱gpt&quot;&gt;拥抱gpt&lt;/h2&gt;
&lt;p&gt;人总是要装逼，呸！人总是要不断追求更高的境界的。在这个人人都用win10的社会，我跟我win7相依为命多年，电脑一开机就被人鄙视。是时候装个win10装点一下门面了。win10就意味着gpt分区。当初曹哥给我装win7用的是mbr，之后我另一个硬盘也只好用mbr（难不成要老夫每次换系统都进一次bios，把legacy换成uefi吗）。所以gpt是必须要有了的。为了避免翻车，我只好在我的固态上面实验（毕竟fedora那时候用的不多装的东西也没多少，重装就是了）。先下载win10，给bios设密码，关掉secureboot，legacy换成uefi,系统刻进u盘。直接在固态clean掉,装上win10没什么意外。这时候我把win7加进启动项开机的时候是有启动win7的，但是却提示缺少什么文件（其实是跨区不行）。上网查了很多，总结几点：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;引导程序(如grub)是有文件系统的，也就是说只要我把secureboot关了，把一个shell改名成那个什么uefi文件，这个shell是会被运行的&lt;/li&gt;
    &lt;li&gt;别人都是可以跨硬盘引导，我的win7好像不可以（我也找到了一个跨硬盘引导失败的人写的blog）&lt;/li&gt;
    &lt;li&gt;bootmgr（好像是这个命令，我忘了）可以根据系统添加引导所需要的文件&lt;/li&gt;
    &lt;li&gt;uefi下面win7的恢复分区没有了不会影响系统的运行与启动&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么方向就有了，既然不可以跨区就双硬盘三驱动。因为我固态还要装fedora，我想保留原生的驱动程序，不敢用grub去引导win10（还记得当年第一次装双驱动的恐惧吗？）。win7的简单，先在win10下保存原来win7的驱动（防止翻车），再直接把原来的引导格掉，换成fat（uefi好像只人这个格式），在win10下把win7引导所需要的文件丢进去。重启f12，找到win7引导，成功开启win7。老样子鼠标动不了，轻车熟路，装驱动，重启一次，ok。这时候win7的破解是没有了的，百度一下破解掉ko。然后刻fedora，直接把fedora的引导装载一个新的分区（我gpt分区就是多任性），简单。
&lt;br /&gt;
现在三座大山
&lt;img src=&quot;/img/boot.jpg&quot; alt=&quot;boot&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;至今三大未解之迷&quot;&gt;至今三大未解之迷&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;一个硬盘双系统为何win7黑屏有开机声音，有声音说明引导是没有问题的，估计也是驱动的问题。鼠标动不了，我可以用键盘装驱动，屏幕不亮…再见&lt;/li&gt;
  &lt;li&gt;为何每次切换系统win7都要重启一次鼠标才能用（win10并不会，win7这个锅要背，可能我之前黑屏也可以重启试试，重启果然很强大）&lt;/li&gt;
  &lt;li&gt;为何我不能跨硬盘引导呢。还要补充一个我fedora升级之后蓝牙用不了，明明驱动都是好的，等以后再找机会求求老卢教我。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 04 Jan 2019 00:00:00 +0800</pubDate>
        <link>/coding/installOs.html</link>
        <guid isPermaLink="true">/coding/installOs.html</guid>
        
        <category>os</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>crack PD Hack</title>
        <description>&lt;h2 id=&quot;外挂使用&quot;&gt;外挂使用&lt;/h2&gt;
&lt;p&gt;这个外挂是通过网络验证的,要先通过服务器注册,再充值,每次使用登陆通过服务器的验证后才可以使用。&lt;br /&gt;
外挂长这样:
&lt;img src=&quot;/img/pdhack/ui.png&quot; alt=&quot;PDHackUI&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;od分析&quot;&gt;od分析&lt;/h2&gt;
&lt;p&gt;知道了网络验证之后思路就基本确定了,找recv send 这些windowsAPI去&lt;br /&gt;
先打开od载入看看内存&lt;br /&gt;
发现401000那里那个段内存是空的什么也没有&lt;br /&gt;
&lt;img src=&quot;/img/pdhack/m401000.png&quot; alt=&quot;m401000&quot; /&gt;
&lt;br /&gt;
&lt;strong&gt;F9让它跑一下,停下来回来发现代码已经被解压出来了&lt;/strong&gt;
&lt;br /&gt;
&lt;img src=&quot;/img/pdhack/m40release.png&quot; alt=&quot;m40release&quot; /&gt;
先给recv下个断点然后跑起来,断下来的时候看一下函数调用盏
&lt;img src=&quot;/img/pdhack/recvFuncCallStack.png&quot; alt=&quot;recvFuncCallStack&quot; /&gt;
但是这里的调用只是给了一部分是不完整的其实前面还有很多，我也不知道怎么让它显示更多。我们直接在右下角的堆栈里找，没猜错的话我们可以找到一些返回40xxxx的地址
&lt;br /&gt;
果不其然
&lt;img src=&quot;/img/pdhack/stackfind40.png&quot; alt=&quot;stackfind40&quot; /&gt;
&lt;br /&gt;
回车回去
&lt;img src=&quot;/img/pdhack/callRecv.png&quot; alt=&quot;callRecv&quot; /&gt;
现在上下拉拉看看就可以找到相关信息,或者直接搜字符串都可以看见了
&lt;img src=&quot;/img/pdhack/string.png&quot; alt=&quot;string&quot; /&gt;
剩下的就是怎么让跳的问题了，没什么技术可言了
&lt;br /&gt;
还有一个就是这个外挂是用易语言写的直接搜ff55fc5f5e可以来到易语言的按钮事件的入口(你总要按登陆吧)，跟进去也可以找到相关的地方&lt;/p&gt;
&lt;h2 id=&quot;写外挂补丁&quot;&gt;写外挂补丁&lt;/h2&gt;
&lt;p&gt;那么现在问题来了，我难道每次打魔兽都要开一次od？
&lt;br /&gt;
别说我不会脱壳哦，老夫可是会脱upx的男人。除了upx…em&lt;br /&gt;
&lt;img src=&quot;/img/expressions/zhishimangqu.jpg&quot; alt=&quot;zhishimangqu&quot; /&gt;
谁说破解一定要脱壳的，我不是不会只是不需要！！！
这个外挂每次开了之后都有一个界面,那么这个时候代码是一定已经解压出来了的，所以我们可以等它自己把代码解压出来之后再把跳转点改过来就ok了。
其实就是开一个进程调试pdhack，然后模拟od的过程把pdhack的代码改了。&lt;br /&gt;
具体py代码这样子&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
from his_debugger_defines import *
msvcrt=cdll.msvcrt
# msvcrt.system(r' start path to pdHack'.encode('gbk'))
kernel32=windll.kernel32
# pid=int(input(&quot;input pid&quot;))
startupinfo=STARTUPINFO()
memset(byref(startupinfo),0,sizeof(startupinfo))
processinformation=PROCESS_INFORMATION()
memset(byref(processinformation),0,sizeof(processinformation))
startupinfo.dwFlags=0x1
startupinfo.wShowWindow=0x1
startupinfo.cb=sizeof(startupinfo)
if kernel32.CreateProcessA(
    r'path to pdHack'.encode('gbk'),
    None,
    None,
    None,
    None,
    0x10,
    None,
    None,
    byref(startupinfo),
    byref(processinformation)
):
    print(&quot;success&quot;)
    kernel32.CloseHandle(processinformation.hThread)
    kernel32.CloseHandle(processinformation.hProcess)
    print(&quot;close&quot;,processinformation.dwProcessId)
    pid=processinformation.dwProcessId
else:
    msvcrt.system(&quot;pause&quot;.encode())
time.sleep(2)
pHandle=kernel32.OpenProcess(PROCESS_ALL_ACCESS,False,pid)
pd=pHandle
def readMemory(ph,address,length):
    data=&quot;&quot;.encode()
    read_buf=create_string_buffer(length)
    count=c_ulong(0)
    if not kernel32.ReadProcessMemory(
            ph,
            address,
            read_buf,
            length,
            byref(count)
        ):
        print(&quot;read memory False&quot;)
        return data
    return data+read_buf.raw
def writeMemory(pd,address,length,data):
    count=c_ulong(0)
    length=len(data)
    c_data=c_char_p(data)
    if not kernel32.WriteProcessMemory(
            pd,
            address,
            c_data,
            length,
            byref(count)
        ):
        print(&quot;write memory false&quot;)
    


# three jmp
address1=0x40476e
address2=0x404794
address3=0x404880
l=6
writeMemory(pd,address1,l,bytes([0x90 for i in range(6)]))
writeMemory(pd,address2,l,bytes([0xeb,0x0e,0x90,0x90,0x90,0x90]))
writeMemory(pd,address3,l,bytes([0x90 for i in range(6)]))

#network
address4=0x4023d0
address5=0x4023bf  
l2=10
writeMemory(pd,address4,l,bytes([0x90 for i in range(6)]))
writeMemory(pd,address5,l2,bytes([0x90 for i in range(l2)]))

# along newwork
address6=0x4053cf
data=[0xB8,0xd5,0x53,0x40,0x00]
data+=[0xc3,50, 48, 52, 48, 51, 52, 0]
writeMemory(pd,address6,len(data),bytes(data))

print(readMemory(pHandle,address1,l))
print(readMemory(pHandle,address2,l))
print(readMemory(pHandle,address3,l))

#40476e   6
#404792   eb 0e 90*4
#404880    6

#40c787 5

# 404713 6
# 40238f  15   
# 4023d0   6

# 4053cf  204034   50 48 52 48 51 52 0

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 03 Jan 2019 00:00:00 +0800</pubDate>
        <link>/coding/pdHack.html</link>
        <guid isPermaLink="true">/coding/pdHack.html</guid>
        
        <category>crack</category>
        
        <category>code</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>关于这个博客</title>
        <description>&lt;h2 id=&quot;搭建&quot;&gt;搭建&lt;/h2&gt;
&lt;p&gt;博客部署在githubpage，只是把域名指向改了，用的jekyll做的静态网页，在&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;jekyll Theme&lt;/a&gt;找了个模板改了一下(理解一下我们这些不会前端的)!模板叫NiceBlog比较简洁，作者觉得现在的模板普遍
&lt;strong&gt;over designed&lt;/strong&gt;,所以搞了个比较简单的！&lt;/p&gt;

&lt;h2 id=&quot;目的&quot;&gt;目的&lt;/h2&gt;
&lt;p&gt;做这个博客倒不是希望有多少人回来看我写的东西，只是给自己一个把学习的过程和成果记录下来的地方。让自己有个写文章的地方，给自己写的动力。&lt;strong&gt;只是我以为没有人看，可能一大堆暗恋我的妹子一天上好几次呢！&lt;/strong&gt;
&lt;br /&gt;
估计我以后回走算法的路，所以以后大部分应该会是关于算法的内容，喜欢算法的同学可以多来转转！&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Jan 2019 00:00:00 +0800</pubDate>
        <link>/introduce/jekyll.html</link>
        <guid isPermaLink="true">/introduce/jekyll.html</guid>
        
        <category>jekyll</category>
        
        <category>me</category>
        
        
        <category>introduce</category>
        
      </item>
    
  </channel>
</rss>
